import React, { useState, useEffect } from 'react';
import {
  View,
  Text,
  TextInput,
  TouchableOpacity,
  StyleSheet,
  Modal,
  Alert,
  KeyboardAvoidingView,
  Platform,
  ScrollView,
  StatusBar,
} from 'react-native';
import { colors } from '../../styles/colors';
import { AssessmentService } from '../../services/assessmentService';
import { useAuth } from '../../context/AuthContext';

interface AssessmentModalProps {
  visible: boolean;
  onClose: () => void;
  course?: any;
  assessment?: any;
  onAssessmentSaved: () => void;
  categoryId?: number; // Pre-selected category ID
  selectedCategoryId?: string; // Pre-selected category from web
  activeSemesterTerm?: string; // Current semester term
  isMidtermCompleted?: boolean; // Whether midterm is completed
}

export const AssessmentModal: React.FC<AssessmentModalProps> = ({
  visible,
  onClose,
  course,
  assessment,
  onAssessmentSaved,
  categoryId,
  selectedCategoryId,
  activeSemesterTerm = 'FINAL_TERM',
  isMidtermCompleted = false,
}) => {
  const { currentUser } = useAuth();
  const [formData, setFormData] = useState({
    name: '',
    maxScore: '',
    date: new Date().toISOString().split('T')[0], // YYYY-MM-DD format
    note: '',
    categoryId: (categoryId?.toString() || selectedCategoryId) || '',
    semesterTerm: activeSemesterTerm,
  });
  const [isLoading, setIsLoading] = useState(false);
  const [categories, setCategories] = useState<any[]>([]);

  useEffect(() => {
    if (visible) {
      loadCategories();
      if (assessment) {
        setFormData({
          name: assessment.name || '',
          maxScore: assessment.maxScore?.toString() || '',
          date: assessment.date || new Date().toISOString().split('T')[0],
          note: assessment.note || '',
          categoryId: assessment.categoryId?.toString() || '',
          semesterTerm: assessment.semesterTerm || activeSemesterTerm,
        });
      } else {
        setFormData({
          name: '',
          maxScore: '',
          date: new Date().toISOString().split('T')[0],
          note: '',
          categoryId: (categoryId?.toString() || selectedCategoryId) || '',
          semesterTerm: activeSemesterTerm,
        });
      }
    }
  }, [visible, assessment, course, categoryId, selectedCategoryId, activeSemesterTerm]);

  // Auto-generate assessment name when categories are loaded and category is pre-selected
  useEffect(() => {
    if (categories.length > 0 && (categoryId || selectedCategoryId) && !assessment && !formData.name) {
      const currentCategoryId = categoryId?.toString() || selectedCategoryId;
      const category = categories.find(cat => cat.id.toString() === currentCategoryId);
      if (category) {
        const categoryName = category.name || category.categoryName;
        // Count existing assessments in this category to generate next number
        const existingAssessments = categories.filter(cat => 
          (cat.name || cat.categoryName) === categoryName
        ).length;
        const nextNumber = existingAssessments + 1;
        const autoGeneratedName = `${categoryName} ${nextNumber}`;
        
        setFormData(prev => ({
          ...prev,
          name: autoGeneratedName,
        }));
      }
    }
  }, [categories, categoryId, selectedCategoryId, assessment, formData.name]);

  const loadCategories = async () => {
    if (!course?.id) return;
    
    try {
      const categoriesData = await AssessmentService.getCategoriesByCourseId(course.id);
      setCategories(Array.isArray(categoriesData) ? categoriesData : []);
    } catch (error) {
      console.error('Error loading categories:', error);
    }
  };

  const handleInputChange = (field: string, value: string) => {
    setFormData(prev => ({
      ...prev,
      [field]: value,
    }));
  };

  const validateForm = () => {
    if (!formData.name.trim()) {
      Alert.alert('Validation Error', 'Assessment name is required');
      return false;
    }

    if (!formData.categoryId) {
      Alert.alert('Validation Error', 'Please select a category');
      return false;
    }

    if (!formData.semesterTerm) {
      Alert.alert('Validation Error', 'Please select a semester term');
      return false;
    }

    // Check if trying to add midterm assessment when midterm is completed
    if (formData.semesterTerm === 'MIDTERM' && isMidtermCompleted) {
      Alert.alert('Validation Error', 'Cannot add midterm assessments when midterm is already completed');
      return false;
    }

    const maxScore = parseFloat(formData.maxScore);
    if (isNaN(maxScore) || maxScore <= 0) {
      Alert.alert('Validation Error', 'Please enter a valid maximum score');
      return false;
    }

    if (!formData.date) {
      Alert.alert('Validation Error', 'Date is required');
      return false;
    }

    return true;
  };

  const handleSubmit = async () => {
    if (!validateForm()) return;
    if (!course?.id) {
      Alert.alert('Error', 'Course information is missing');
      return;
    }

    setIsLoading(true);
    try {
      const assessmentData = {
        courseId: course.id,
        name: formData.name.trim(),
        maxScore: parseFloat(formData.maxScore),
        date: formData.date,
        note: formData.note.trim(),
        categoryId: parseInt(formData.categoryId),
        semesterTerm: formData.semesterTerm,
      };

      console.log('Submitting assessment data:', assessmentData);
      console.log('Course ID:', course.id);
      console.log('Assessment ID (if editing):', assessment?.id);

      if (assessment) {
        console.log('Updating existing assessment...');
        await AssessmentService.updateAssessment(assessment.id, assessmentData);
        Alert.alert('Success', 'Assessment updated successfully!');
      } else {
        console.log('Creating new assessment...');
        const result = await AssessmentService.createAssessment(assessmentData);
        console.log('Assessment creation result:', result);
        Alert.alert('Success', 'Assessment created successfully!');
        
      }
      
      onAssessmentSaved();
      onClose();
    } catch (error: any) {
      console.error('Error saving assessment:', error);
      console.error('Error details:', {
        message: error.message,
        response: error.response?.data,
        status: error.response?.status,
        statusText: error.response?.statusText
      });
      Alert.alert(
        'Error',
        error.response?.data?.message || error.message || 'Failed to save assessment. Please try again.'
      );
    } finally {
      setIsLoading(false);
    }
  };

  return (
     <Modal
       visible={visible}
       animationType="slide"
       transparent={false}
       presentationStyle={Platform.OS === 'ios' ? 'fullScreen' : undefined}
       onRequestClose={onClose}
     >
      <View style={styles.container}>
        <StatusBar backgroundColor={colors.green[500]} barStyle="light-content" translucent={true} />
        <KeyboardAvoidingView 
          behavior={Platform.OS === 'ios' ? 'padding' : 'height'}
          style={styles.keyboardAvoidingView}
        >
          <View style={styles.modalContent}>
               {/* Modal Header */}
               <View style={styles.header}>
                 <TouchableOpacity onPress={onClose} style={styles.closeButton}>
                   <Text style={styles.closeButtonText}>âœ•</Text>
                 </TouchableOpacity>
                 <Text style={styles.title}>
                   {assessment ? 'Edit Assessment' : 'Add New Assessment'}
                 </Text>
                 <View style={styles.placeholder} />
               </View>

               <ScrollView 
                 style={styles.content} 
                 showsVerticalScrollIndicator={false}
                 contentContainerStyle={styles.scrollContent}
               >
                {/* Category Selection - Show dropdown only if no category is pre-selected */}
                {!categoryId && !selectedCategoryId ? (
                  <View style={styles.inputGroup}>
                    <Text style={styles.label}>Category</Text>
                    <View style={styles.selectContainer}>
                      {categories.length > 0 ? (
                        <View style={styles.categoryContainer}>
                          {categories.map((category) => (
                            <TouchableOpacity
                              key={category.id}
                              style={[
                                styles.categoryOption,
                                formData.categoryId === category.id.toString() && styles.categoryOptionSelected,
                              ]}
                              onPress={() => handleInputChange('categoryId', category.id.toString())}
                            >
                              <Text style={[
                                styles.categoryOptionText,
                                formData.categoryId === category.id.toString() && styles.categoryOptionTextSelected,
                              ]}>
                                {category.name || category.categoryName}
                              </Text>
                            </TouchableOpacity>
                          ))}
                        </View>
                      ) : (
                        <Text style={styles.noCategoriesText}>
                          No categories available. Please create categories first.
                        </Text>
                      )}
                    </View>
                  </View>
                ) : (
                  /* Show pre-selected category as embedded field */
                  <View style={styles.inputGroup}>
                    <Text style={styles.label}>Category</Text>
                    <View style={styles.embeddedField}>
                     <Text style={styles.embeddedText}>
                       {(() => {
                         const currentCategoryId = categoryId?.toString() || selectedCategoryId;
                         const category = categories.find(cat => cat.id.toString() === currentCategoryId);
                         return category ? (category.name || category.categoryName) : 'Selected Category';
                       })()}
                     </Text>
                    </View>
                    <Text style={styles.helperText}>
                      Category is embedded from the selected category section
                    </Text>
                  </View>
                )}

                {/* Semester Term */}
                <View style={styles.inputGroup}>
                  <Text style={styles.label}>Semester Term</Text>
                  <View style={styles.horizontalSelectContainer}>
                    <TouchableOpacity
                      style={[
                        styles.termOptionHorizontal,
                        formData.semesterTerm === 'MIDTERM' && styles.termOptionSelected,
                        isMidtermCompleted && styles.termOptionDisabled,
                      ]}
                      onPress={() => !isMidtermCompleted && handleInputChange('semesterTerm', 'MIDTERM')}
                      disabled={isMidtermCompleted}
                    >
                      <Text style={[
                        styles.termOptionText,
                        formData.semesterTerm === 'MIDTERM' && styles.termOptionTextSelected,
                        isMidtermCompleted && styles.termOptionTextDisabled,
                      ]}>
                        Midterm {isMidtermCompleted ? '(Completed - Locked)' : ''}
                      </Text>
                    </TouchableOpacity>
                    <TouchableOpacity
                      style={[
                        styles.termOptionHorizontal,
                        formData.semesterTerm === 'FINAL_TERM' && styles.termOptionSelected,
                      ]}
                      onPress={() => handleInputChange('semesterTerm', 'FINAL_TERM')}
                    >
                      <Text style={[
                        styles.termOptionText,
                        formData.semesterTerm === 'FINAL_TERM' && styles.termOptionTextSelected,
                      ]}>
                        Final Term
                      </Text>
                    </TouchableOpacity>
                  </View>
                  {isMidtermCompleted && (
                    <Text style={styles.errorText}>
                      Cannot add midterm assessments when midterm is already completed
                    </Text>
                  )}
                </View>

                {/* Assessment Name */}
                <View style={styles.inputGroup}>
                  <Text style={styles.label}>Assessment Name</Text>
                  <TextInput
                    style={styles.input}
                    value={formData.name}
                    onChangeText={(value) => handleInputChange('name', value)}
                    placeholder="Auto-generated based on category"
                    placeholderTextColor={colors.gray[400]}
                  />
                  <Text style={styles.helperText}>
                    Name will auto-generate based on category (e.g., "Quiz 1", "Assignment 2"), or customize as needed
                  </Text>
                </View>

                {/* Maximum Score */}
                <View style={styles.inputGroup}>
                  <Text style={styles.label}>Maximum Score</Text>
                  <TextInput
                    style={styles.input}
                    value={formData.maxScore}
                    onChangeText={(value) => handleInputChange('maxScore', value)}
                    placeholder="Enter maximum score"
                    keyboardType="numeric"
                    placeholderTextColor={colors.gray[400]}
                  />
                  <Text style={styles.helperText}>
                    Enter the maximum possible score for this assessment
                  </Text>
                </View>

                {/* Date */}
                <View style={styles.inputGroup}>
                  <Text style={styles.label}>Date</Text>
                  <TextInput
                    style={styles.input}
                    value={formData.date}
                    onChangeText={(value) => handleInputChange('date', value)}
                    placeholder="YYYY-MM-DD"
                    placeholderTextColor={colors.gray[400]}
                  />
                  <Text style={styles.helperText}>
                    When this assessment is due
                  </Text>
                </View>

                {/* Note */}
                <View style={styles.inputGroup}>
                  <Text style={styles.label}>Note</Text>
                  <TextInput
                    style={[styles.input, styles.textArea]}
                    value={formData.note}
                    onChangeText={(value) => handleInputChange('note', value)}
                    placeholder="Add any additional notes about this assessment..."
                    placeholderTextColor={colors.gray[400]}
                    multiline
                    numberOfLines={3}
                    textAlignVertical="top"
                  />
                   <Text style={styles.helperText}>
                     Optional notes or instructions for this assessment
                   </Text>
                 </View>
               </ScrollView>

              {/* Modal Footer */}
              <View style={styles.footer}>
                <TouchableOpacity
                  onPress={onClose}
                  style={styles.cancelButton}
                >
                  <Text style={styles.cancelButtonText}>Cancel</Text>
                </TouchableOpacity>
                <TouchableOpacity
                  onPress={handleSubmit}
                  style={[styles.submitButton, isLoading && styles.submitButtonDisabled]}
                  disabled={isLoading}
                >
                  <Text style={styles.submitButtonText}>
                    {isLoading ? 'Saving...' : (assessment ? 'Update Assessment' : 'Add Assessment')}
                  </Text>
                </TouchableOpacity>
               </View>
             </View>
           </KeyboardAvoidingView>
         </View>
     </Modal>
  );
};

const styles = StyleSheet.create({
   container: {
     flex: 1,
     backgroundColor: colors.green[500],
   },
   keyboardAvoidingView: {
     flex: 1,
   },
  modalContent: {
    flex: 1,
    backgroundColor: colors.background.primary,
    flexDirection: 'column',
  },
  header: {
    backgroundColor: colors.green[500],
    paddingHorizontal: 24,
    paddingVertical: 16,
    paddingTop: Platform.OS === 'ios' ? 50 : (StatusBar.currentHeight || 0) + 16,
    flexDirection: 'row',
    alignItems: 'center',
    justifyContent: 'space-between',
  },
  title: {
    fontSize: 20,
    fontWeight: 'bold',
    color: colors.text.white,
    textAlign: 'center',
    flex: 1,
  },
  closeButton: {
    padding: 8,
  },
  closeButtonText: {
    fontSize: 18,
    color: colors.text.white,
    fontWeight: 'bold',
  },
  placeholder: {
    width: 34, // Same width as close button to center the title
  },
  content: {
    flex: 1,
  },
  scrollContent: {
    padding: 24,
    paddingBottom: 100, // Extra padding to ensure content is not hidden behind buttons
  },
  inputGroup: {
    marginBottom: 16,
  },
  label: {
    fontSize: 14,
    fontWeight: '500',
    color: colors.text.primary,
    marginBottom: 4,
  },
  input: {
    backgroundColor: colors.background.secondary,
    borderWidth: 1,
    borderColor: colors.border.medium,
    borderRadius: 8,
    paddingHorizontal: 12,
    paddingVertical: 12,
    fontSize: 16,
    color: colors.text.primary,
  },
  textArea: {
    height: 80,
    textAlignVertical: 'top',
  },
  helperText: {
    fontSize: 12,
    color: colors.text.secondary,
    marginTop: 4,
    fontStyle: 'italic',
  },
  errorText: {
    fontSize: 12,
    color: colors.red[500],
    marginTop: 4,
  },
  selectContainer: {
    gap: 8,
  },
  horizontalSelectContainer: {
    flexDirection: 'row',
    gap: 8,
  },
  categoryContainer: {
    gap: 8,
  },
  categoryOption: {
    padding: 12,
    backgroundColor: colors.background.secondary,
    borderWidth: 1,
    borderColor: colors.border.medium,
    borderRadius: 8,
  },
  categoryOptionSelected: {
    backgroundColor: colors.green[500],
    borderColor: colors.green[500],
  },
  categoryOptionText: {
    fontSize: 16,
    fontWeight: '500',
    color: colors.text.primary,
  },
  categoryOptionTextSelected: {
    color: colors.text.white,
  },
  embeddedField: {
    paddingHorizontal: 12,
    paddingVertical: 12,
    backgroundColor: colors.gray[100],
    borderWidth: 1,
    borderColor: colors.border.medium,
    borderRadius: 8,
  },
  embeddedText: {
    fontSize: 16,
    color: colors.text.primary,
    fontWeight: '500',
  },
  termOption: {
    padding: 12,
    backgroundColor: colors.background.secondary,
    borderWidth: 1,
    borderColor: colors.border.medium,
    borderRadius: 8,
  },
  termOptionHorizontal: {
    flex: 1,
    padding: 12,
    backgroundColor: colors.background.secondary,
    borderWidth: 1,
    borderColor: colors.border.medium,
    borderRadius: 8,
    alignItems: 'center',
  },
  termOptionSelected: {
    backgroundColor: colors.green[500],
    borderColor: colors.green[500],
  },
  termOptionDisabled: {
    backgroundColor: colors.gray[200],
    borderColor: colors.gray[300],
  },
  termOptionText: {
    fontSize: 16,
    fontWeight: '500',
    color: colors.text.primary,
  },
  termOptionTextSelected: {
    color: colors.text.white,
  },
  termOptionTextDisabled: {
    color: colors.gray[500],
  },
  noCategoriesText: {
    fontSize: 14,
    color: colors.text.secondary,
    fontStyle: 'italic',
    textAlign: 'center',
    paddingVertical: 20,
  },
  footer: {
    flexDirection: 'row',
    justifyContent: 'flex-end',
    gap: 8,
    padding: 24,
    paddingTop: 16,
    backgroundColor: colors.background.primary,
  },
  cancelButton: {
    paddingVertical: 12,
    paddingHorizontal: 16,
    borderWidth: 1,
    borderColor: colors.border.medium,
    borderRadius: 8,
    backgroundColor: colors.background.primary,
  },
  cancelButtonText: {
    fontSize: 16,
    color: colors.text.secondary,
    fontWeight: '500',
  },
  submitButton: {
    backgroundColor: colors.green[500],
    paddingVertical: 12,
    paddingHorizontal: 16,
    borderRadius: 8,
  },
  submitButtonDisabled: {
    backgroundColor: colors.gray[400],
  },
  submitButtonText: {
    fontSize: 16,
    color: colors.text.white,
    fontWeight: '600',
  },
});
